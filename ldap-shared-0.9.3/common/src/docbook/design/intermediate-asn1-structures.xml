<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V4.1.2.5//EN"
	"http://www.oasis-open.org/docbook/xml/simple/4.1.2.5/sdocbook.dtd">

<article class="whitepaper">
	<title>Intermediate ASN.1 Structures: The Agnostic Message Framework</title>
    
    <articleinfo>
        <author><othername>akarasulu</othername></author>
        <editor><othername>$Author: akarasulu $</othername></editor>
        <revhistory>
            <revision>
                <revnumber>$Revision: 1.7 $</revnumber>
                <date>$Date: 2003/04/27 16:54:27 $</date>
                <revdescription>
                    <para>
$Log: intermediate-asn1-structures.xml,v $
Revision 1.7  2003/04/27 16:54:27  akarasulu
Changed message APIs to use String instead of Name and to use Attributes
instead of MultiMap.

Revision 1.6  2003/04/21 15:51:26  akarasulu
The Lockable character of Messages are a requirement of the framework not
of a particular implementation.  Hence Message interfaces should extend the
Lockable interface rather than have AbstractMessage just extend the
AbstractLockable interface.  This means that all providers who supply their
own Message implementations must make sure their implememtation classes
are Lockables.

Revision 1.5  2003/04/16 20:05:17  akarasulu
Small fixes and adding sequence diagrams to show SPI based [de]marshalling
behavoir/interactions.

Revision 1.4  2003/04/14 05:34:03  akarasulu
Changed provider to so that it is its own factory as well as a factory for
creating Provider class instances.  Now we need to integrate this with the
MessageDecoder and MessageEncoder classes.

Revision 1.3  2003/04/13 17:33:17  akarasulu
Working more on defining the ASN.1 BER library provider architecture.

Revision 1.2  2003/04/11 21:38:10  akarasulu
In progress with Message decoder and encoders.

Revision 1.1  2003/04/10 21:02:44  akarasulu
Added BER encoder decoder service provider interfaces (spi) used to
marshal and demarshal messages as well as transform them to the
cannonical library independant forms within the message package.

                    </para>
                </revdescription>
            </revision>
        </revhistory>
    </articleinfo>

	<abstract>
		<para>
            Describe the design used to minimize BER library and ASN.1 stub 
            dependancies to the point where BER library providers are pluggable.
		</para>
	</abstract>
    
    <section>
        <title>Document TODOs and Notes:</title>
        
        <itemizedlist>
            <listitem><para>
                Add the seq/collab diagrams.
            </para></listitem>
            <listitem><para>
                Discuss the structure of the message package with respect to the
                Message interface inheritance heirarchy and Lockables.  Also 
                describe the concept of Lockable containment heirarchies.
            </para></listitem>
        </itemizedlist>
    </section>
    
    <section>
        <title>Background</title>
        
        <para>
            Both clients and servers are receivers and transmitters of LDAP 
            Protocol Data Units (PDU).  Clients recieve response PDUs and 
            transmit request PDUs.  Servers recieve requests and transmit 
            responses.  PDU reception entails the demarshalling of message 
            parameter data encoded serially.  Demarshalling is the process of 
            reading incomming bytes, decoding them into the appropriate in 
            memory representations, and building a containment tree to represent
            the PDU's message envelope with all its parameters.  Marshaling is 
            the opposite process of encoding the parameters of a PDU message 
            envelope in memory into a serialized byte representation for 
            transmission.
        </para>
        
        <para>
            Our greatest concerns rest in establishing a common and dependancy
            free logical representation for in memory PDU message envelopes.  
            PDU's and their contained parameters are accessed by various parts
            of the server and by client code as well.  By using a BER library 
            agnostic LDAPv3 PDU message API we prevent clients and servers from
            becoming berlib provider dependant.  We would ultimately like to 
            make berlib providers plugable, erradicate berlib specific 
            dependancies throughout client and server code, and better define
            the structure of LDAPv3 PDU's.
        </para>
        
    </section>
    
    <section>
        <title>Use Cases and Requirements</title>
        
        <para>
            The request response nature of LDAP requires both clients and 
            servers to build outgoing message envelopes and access incoming
            message envelopes.  Clients build requests and access demarshaled 
            response PDUs.  Servers access request PDUs and where appropriate 
            build one or more responses as replies to a request.  Clients and 
            servers both need to build envelopes and access their contents.  
            Consequently, both need to marshal and demarshal messages to and 
            from byte streams for PDU receiption and transmission.
        </para>
        
        <para>
            On the recieving end the final product of PDU demarshalling is an 
            instance of an agnostic LDAPv3 PDU message envelope.  Whether the 
            PDU is a request recieved by a server or response received by a 
            client, the same message interfaces are exposed to message handling
            routines no matter which BER librarary implementation is used.  The
            process of reading incomming bytes to compose this common logical 
            representation requires two steps.  First the BER library 
            demarshalls the PDU into its implementation specific in memory 
            representation.  The implementation specific PDU is then transformed
            into the common logical representation.  The transformed Message is
            the final library independent representation returned to the decode
            operation caller.
        </para>
        
        <para>
            In the opposite direction to marshall outgoing messages, agnostic
            Message API's are used to compose a PDU message envelope in memory.
            Message handling routines in clients and the server use these berlib
            independent APIs to build PDUs without having to know the details
            of BER library implementations.  PDU encoding follows composition
            using BER library encoders.  These encoders however can only encode 
            PDU's built using implementation specific stubs generated by the 
            library's stub compiler.  PDUs must be transformed from the library 
            independent representation to the berlib implementation dependent 
            message envelope so library encoders can marshall the PDU.  
            Marshalling involves the two similar phases however in the opposite 
            order: PDU transformation takes place first followed by encoding.
        </para>
        
        <para>
            Show the sequence diagrams for marshalling and demarshalling 
            collaborations.
        </para>
        
        <para>
            The two phased [de]marshal and transform approach copies data in one
            place at one time.  Otherwise the data would be copied in different
            places across the stages of PDU processing.  This is a small price 
            to pay for stub library independance, a better architecture and 
            ultimately a cleaner healthier message handling code base.
        </para>

        <para>
            Recieved PDUs must not be tampered with during the course of their
            processing.  Once built and transmitted by another external process
            the PDU should not be altered even after the recieving process 
            demarshalls it.  The recieved PDU represents the final PDU image
            right before transmission and the recieving process must make sure
            the PDU is immutable after reception.  The same APIs used to enable
            data protection for recieved PDUs is used to compose those PDUs on
            the transmitting process.  The act of composition inherently 
            requires the ability one way or another to alter the PDU's
            parameters.  Data protection against mutators and PDU construction
            impose conflicting requirements.  There are multiple design 
            approaches that may be used to guarrantee data protection for 
            recieved messages while allowing the composition of outgoing 
            messages for transmission.  We touch upon some of these approaches 
            below:
        </para>
        
        <itemizedlist>
            <listitem>
            <para>
            Message PDU APIs do not expose PDU parameter mutator methods.  Each 
            BER library used supplies its own set of Message interface 
            implementations exposing package friendly PDU parameter mutator 
            methods.  An implementation supplied Builder in the same package 
            induces changes to messages during PDU construction using these 
            package friendly mutators.  The Builder interface exposes methods
            used to alter message PDU parameters.  Builder implementations route
            these calls to the appropriate package friendly PDU parameter 
            mutators.
            </para>
            
            <para>
            The primary disadvantage here is that every provider must supply a
            set of PDU interface implemenations with package friendly mutators.
            Another major drawback is the need to mirror mutator functionality
            on builder interfaces for all interfaces using in PDU construction.
            This makes for a conjested interface with several methods.  Each
            BER library used requires a Builder implemenation within the same
            package contain PDU value object interface implementations.
            </para>
            </listitem>
            
            <listitem>
            <para>
            Expose two different kinds of Message envelope interfaces: mutable
            and immutatable.  A Message factory used to instantiate initial 
            message envelopes can return mutable versions of Message interfaces.
            The message interfaces returned by message decoders can be immutable
            to prevent alteration.
            </para>
            
            <para>
            The major drawback here is having two interfaces for each PDU 
            message type: one immutable read-only interface and another mutable
            interface.  Read-only instances will need to be built and building
            them requires access to mutators.  Many techniques can be used to
            prevent external access to these mutators used to build the read- 
            only PDU however they do not provide complete protection.  Data 
            protection is a matter of state.  Once PDU demarshalled has 
            completed mutators should no longer work: mutators are in a locked
            state.
            </para>
            </listitem>
            
            <listitem>
            <para>
            Expose all PDU parameter accessors and mutators in the same 
            interface.  Create default implementations which implement a 
            Lockable interface used to lock down mutators by throwing runtime 
            LockExceptions.  PDU's resulting from demarshaling pathways can be 
            locked down immediately after construction.  PDU's to be 
            transmitted, can be locked down after composition but before 
            transmission.
            </para>
            
            <para>
            This is the best approach.  One and only one interface is used to
            represent each PDU message type.  One implementation is provided for
            for each PDU message type which implements the Lockable interface.
            All BER library implementations can use these Lockable PDU envelope 
            value objects while still having the option of implementing their
            own.
            </para>
            
            </listitem>
        </itemizedlist>
        
    </section>
    
    <section>
        <title>Design</title>
        
        <para>
            Berlib agnostic or logical Message APIs are implementation 
            independent.  Implemenation independence requires the strict use of 
            interfaces.  Interfaces rather than classes are used to model the
            logical representations of LDAPv3 ASN.1 Message structures 
            independent of the implemenation used to encode and decode them.  We
            have remained true in the strict use of interfaces.  All Messages, 
            their subtypes (like, i.e. a AddRequest) and contained protocol data
            types (like i.e. a Control) have been defined as interfaces.
        </para>
        
        <para>
            ASN.1 stub compilers could provide pragmas to generate stubs 
            implementing these interfaces.  It would be ideal if all compilers
            could do so, but not many do.  Even if they did data type conversion
            would require custom code adjustments.  Compiler generated stubs 
            leverage runtime BER library encoders and decoders.  These generated
            stub based PDUs need to be transformed to and from classes 
            implementing our berlib agnostic Message interfaces.  Berlib and 
            stub specific code would be required to encode, decode and transform
            PDUs to and from our canonical Message interfaces.  All together we 
            refer to the runtime berlib encoders/decoders, the generated 
            compiler stub classes, and the code used to transform PDUs into 
            their logical agnostic forms (and vice-versa) as being the parts of 
            a berlib provider.
        </para>
        
        <para>
            Incorporation of the provider design pattern within the Message 
            framework isolates BER library dependencies making implementations 
            pluggable.  The goal of the provider pattern is to generalize 
            functionality using common service provider interfaces.  Service 
            provider interfaces declare generic signatures used by the Message 
            framwork to request work from the provider without knowing the 
            implementation details associated with the BER library.  Calls made
            to the Message framework to decode or encode messages internally use
            the SPI implementations supplied by the provider. BER library 
            decoders and encoders are generalized using the 
            ldapd.common.message.spi interfaces, DecoderSpi and EncoderSpi 
            respectively.  These interfaces declare the aforementioned generic 
            signatures for these functions which must be implemented by any 
            berlib service provider.  An additional TransformerSpi declares 
            generic methods which bidirectionally transform provider PDU 
            envelopes to and from agnostic Message PDU envelopes.  Together 
            these three interfaces compose the set of BER library service 
            provider interfaces.  Providers implement these interfaces for their
            BER libraries and the LDAPv3 ASN.1 stub classes generate by their 
            specific stub compilers.  The SPIs make providers pluggable by
            hiding and isolating their implementation details.  The Message 
            framework API exposed to clients and servers hides these provider 
            nuances removing dependence on provider classes by both client and 
            server code bases.  Ultimately the pattern acheives the goals of 
            provider pluggability and hence berlib independence.
        </para>
        
        <para>
            The reduction of marshalling and demarshalling processes into two
            phases clarifies interactions between DecoderSpi, EncoderSpi and
            TransformerSpi implementations.  The interfaces are shown here in 
            the <ulink url="/SpiPackage.gif">SPI Package Diagram</ulink>.  
            Providers must supply implementations for these SPIs, wrapping their
            specific BER library functions with these interfaces.
        </para>
    </section>

    <section>
        <title>Addendum and Notes</title>
        
        <para>
            The requests and responses currently are designed to represent names
            as fully parsed javax.naming.Name instances.  This may not be the 
            best way to proceed.  It's best to leave the name as a String since
            some API applications will never parse the Dn to begin with.  Why 
            then parse the Dn for each application?  Also note that doing so for
            the Dn would require it to be done for a filter and so on.
        </para>
        
        <para>
            Made a decisive decision to use Attributes interface in message API
            rather than using the LdapEntry or MultiMap interfaces.  This makes
            the client and server side API more JNDI-esque and hence familiar.
            The implementation can use a multimap and its implementations 
            underneath to implement the Attributes.  Ultimately these decisions
            bring us closer to an easier the redisign of the backend interfaces
            of the server.
        </para>
    </section>
    
    <section>
        <title>Faults</title>
        
        <para>
        </para>
    </section>
    
    <section>
        <title>Future</title>
        
        <para>
            On the fly ASN.1 spec based data type generation using byte code
            generation tools.  This will be required for Control value handling 
            and extended request payload handling.  Other ASN.1 data types may
            need to be defined.
        </para>
        
        <para>
            Write an ASN.1 stub compiler which generates stubs using supplied
            interfaces rather than using two phase process.
        </para>
    </section>
    
</article>    

