/*
 *   Copyright 2004 The Apache Software Foundation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */
package org.apache.asn1.ber ;


import org.apache.asn1.codec.stateful.CallbackHistory;

import java.nio.ByteBuffer;


/**
 * $todo$ doc me
 *
 * @author <a href="mailto:dev@directory.apache.org">
 * Apache Directory Project</a>
 * @version $Rev$
 */
public class LdapMessageTests extends AbstractDecoderTestCase
{
    TupleTreeDecoder ttd = null ;
    CallbackHistory history = null ;
    
    
    public LdapMessageTests()
    {
        super ( LdapMessageTests.class.getName() ) ;
    }
    
    
    /* (non-Javadoc)
     * @see org.apache.asn1.ber.AbstractDecoderTestCase#setUp()
     */
    protected void setUp() throws Exception
    {
        super.setUp();
        
        ttd = new TupleTreeDecoder() ;
        history = new CallbackHistory( 1 ) ;
        ttd.setCallback( history ) ;
    }
    
    
    /* (non-Javadoc)
     * @see org.apache.asn1.ber.AbstractDecoderTestCase#tearDown()
     */
    protected void tearDown() throws Exception
    {
        super.tearDown();
        
        ttd = null ;
        history = null ;
    }
    
    
    /**
     * Creates a tuple node tree from a message.
     * 
     * @param pdu the message to encode and decode
     * @return
     * @throws Exception
     */
    public DefaultMutableTupleNode roundTripTest( byte[] pdu ) throws Exception
    {
        DefaultMutableTupleNode node = null ;
        ByteBuffer buf1 = ByteBuffer.wrap( pdu ) ;
        ttd.decode( buf1 ) ;
        node = ( DefaultMutableTupleNode ) history.getMostRecent() ;

        ByteBuffer buf2 = ByteBuffer.allocate( node.size() ) ;
        node.encode( buf2 ) ;
        assertTrue( buf1.equals( buf2 ) ) ;

        return node ;
    }

    public void testBindMessage() throws Exception
    {
        byte[] pdu = {0x30, 0x33, 0x02, 0x01, 0x01, 0x60, 0x2E, 0x02, 0x01, 0x03, 0x04, 0x1F, 0x75, 0x69, 0x64, 0x3D, 0x61, 0x6B, 0x61, 0x72, 0x61, 0x73, 0x75, 0x6C, 0x75, 0x2C, 0x64, 0x63, 0x3D, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2C, 0x64, 0x63, 0x3D, 0x63, 0x6F, 0x6D, 0xFFFFFF80, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64};

        decode( pdu ) ;
        roundTripTest( pdu ) ;
        assertFalse( tlvList.isEmpty() ) ;
    }

    public void testAddMessage() throws Exception
    {
        byte[] pdu = {0x30, 0x6D, 0x02, 0x01, 0x01, 0x68, 0x68, 0x04, 0x1F, 0x75, 0x69, 0x64, 0x3D, 0x61, 0x6B, 0x61, 0x72, 0x61, 0x73, 0x75, 0x6C, 0x75, 0x2C, 0x64, 0x63, 0x3D, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2C, 0x64, 0x63, 0x3D, 0x63, 0x6F, 0x6D, 0x30, 0x45, 0x30, 0x0F, 0x04, 0x05, 0x61, 0x74, 0x74, 0x72, 0x31, 0x31, 0x06, 0x04, 0x04, 0x76, 0x61, 0x6C, 0x30, 0x30, 0x15, 0x04, 0x05, 0x61, 0x74, 0x74, 0x72, 0x32, 0x31, 0x0C, 0x04, 0x04, 0x76, 0x61, 0x6C, 0x31, 0x04, 0x04, 0x76, 0x61, 0x6C, 0x30, 0x30, 0x1B, 0x04, 0x05, 0x61, 0x74, 0x74, 0x72, 0x30, 0x31, 0x12, 0x04, 0x04, 0x76, 0x61, 0x6C, 0x30, 0x04, 0x04, 0x76, 0x61, 0x6C, 0x31, 0x04, 0x04, 0x76, 0x61, 0x6C, 0x32};

        decode( pdu ) ;
        roundTripTest( pdu ) ;
        assertFalse( tlvList.isEmpty() ) ;
    }


    public void testDeleteMessage() throws Exception
    {
        byte[] pdu = {0x30, 0x24, 0x02, 0x01, 0x01, 0x4A, 0x1F, 0x75, 0x69, 0x64, 0x3D, 0x61, 0x6B, 0x61, 0x72, 0x61, 0x73, 0x75, 0x6C, 0x75, 0x2C, 0x64, 0x63, 0x3D, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2C, 0x64, 0x63, 0x3D, 0x63, 0x6F, 0x6D};

        decode( pdu ) ;
        roundTripTest( pdu ) ;
        assertFalse( tlvList.isEmpty() ) ;
    }


    public void testAbandonMessage() throws Exception
    {
        byte[] pdu = new byte[] {0x30, 0x06, 0x02, 0x01, 0x01, 0x50, 0x01, 0x03};

        decode( pdu ) ;
        roundTripTest( pdu ) ;
        assertFalse( tlvList.isEmpty() ) ;
    }


    public void testCompareMessage() throws Exception
    {
        byte[] pdu = {0x30, 0x3D, 0x02, 0x01, 0x01, 0x6E, 0x38, 0x04, 0x1F, 0x75, 0x69, 0x64, 0x3D, 0x61, 0x6B, 0x61, 0x72, 0x61, 0x73, 0x75, 0x6C, 0x75, 0x2C, 0x64, 0x63, 0x3D, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2C, 0x64, 0x63, 0x3D, 0x63, 0x6F, 0x6D, 0x30, 0x15, 0x04, 0x08, 0x74, 0x65, 0x73, 0x74, 0x61, 0x74, 0x74, 0x72, 0x04, 0x09, 0x74, 0x65, 0x73, 0x74, 0x76, 0x61, 0x6C, 0x75, 0x65};

        decode( pdu ) ;
        roundTripTest( pdu ) ;
        assertFalse( tlvList.isEmpty() ) ;
    }


    public void testExtendedMessage() throws Exception
    {
        byte[] pdu = {0x30, 0x22, 0x02, 0x01, 0x01, 0x77, 0x1D, 0xFFFFFF80, 0x0E, 0x31, 0x32, 0x33, 0x34, 0x2E, 0x31, 0x32, 0x33, 0x34, 0x2E, 0x31, 0x33, 0x32, 0x34, 0xFFFFFF81, 0x0B, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64};

        decode( pdu ) ;
        roundTripTest( pdu ) ;
        assertFalse( tlvList.isEmpty() ) ;
    }


    public void testModifyDnMessage() throws Exception
    {
        byte[] pdu = {0x30, 0x45, 0x02, 0x01, 0x01, 0x6C, 0x40, 0x04, 0x1F, 0x75, 0x69, 0x64, 0x3D, 0x61, 0x6B, 0x61, 0x72, 0x61, 0x73, 0x75, 0x6C, 0x75, 0x2C, 0x64, 0x63, 0x3D, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2C, 0x64, 0x63, 0x3D, 0x63, 0x6F, 0x6D, 0x04, 0x07, 0x75, 0x69, 0x64, 0x3D, 0x61, 0x6F, 0x6B, 0x01, 0x01, 0xFFFFFFFF, 0xFFFFFF80, 0x11, 0x64, 0x63, 0x3D, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2C, 0x64, 0x63, 0x3D, 0x63, 0x6F, 0x6D};

        decode( pdu ) ;
        roundTripTest( pdu ) ;
        assertFalse( tlvList.isEmpty() ) ;
    }


    /* ------------------------------------------------------------------------
     
Here's what the modify message looks like:
     
LDAP Modify Operation without any modification items
dn = "uid=akarasulu,dc=example,dc=com"
message id = 17

[
0  -> 48  0x30, 0011 0000 (const) Universal id = 16 
                Sequence and Sequence-of types
1  -> 42  0x2a, 0100 0010 length = 42

   [
    2  -> 2   0x2,  0000 0010 (prim) Universal id = 2, Integer type
    3  -> 1   0x1,  0000 0001 length = 1 
    4  -> 17  0x11, 0001 0001 integer value = 17
   ]

   [
    5  -> 102 0x66, 0110 0110 (const) Application id = 6
                    LDAPv3 RFC 2251 defines APPLICATION 6 for ModifyRequests
    6  -> 35  0x23, 0010 0011 length = 35
       [
           7  -> 4   0x4,  0000 0100  ( prim ) UNIVERSAL id = 4
                           Octetstring type
           8  -> 31  0x1f, 0001 1111  length = 31

           Octetstring = "uid=akarasulu,dc=example,dc=com"

           [117, 105, 100, 61, 97, 107, 97, 114, 97, 115, 117, 108, 117, 44, 
            100, 99, 61, 101, 120, 97, 109, 112, 108, 101, 44, 100, 99, 61, 
            99, 111, 109]


            9  -> 117 0x75, 
            10 -> 105 0x69, 
            11 -> 100 0x64, 
            12 -> 61  0x3d, 
            13 -> 97  0x61, 
            14 -> 107 0x6b, 
            15 -> 97  0x61, 
            16 -> 114 0x72, 
            17 -> 97  0x61, 
            18 -> 115 0x73, 
            19 -> 117 0x75, 
            20 -> 108 0x6c, 
            21 -> 117 0x75, 
            22 -> 44  0x2c, 
            23 -> 100 0x64, 
            24 -> 99  0x63, 
            25 -> 61  0x3d, 
            26 -> 101 0x65, 
            27 -> 120 0x78, 
            28 -> 97  0x61, 
            29 -> 109 0x6d, 
            30 -> 112 0x70, 
            31 -> 108 0x6c, 
            32 -> 101 0x65, 
            33 -> 44  0x2c, 
            34 -> 100 0x64, 
            35 -> 99  0x63, 
            36 -> 61  0x3d, 
            37 -> 99  0x63, 
            38 -> 111 0x6f, 
            39 -> 109 0x6d,

38    33    40 -> 48  0x30, 0011 0000 (const) Universal id = 16
                            Sequence and Sequence-of types
39    34    41 -> 0   0x0,  length = 0
    
        ]
    
    [
40  42 -> -96 0xa0, 1010 0000 (prim) Context-specific id = 0
                    "controls" part of the LDAP message Envelope
                    is specified as context-specific [0] when no
                    no type class name is explicitly given

        LDAPMessage ::= SEQUENCE 
        {
            messageID INTEGER,
            protocolOp CHOICE { ... },
            controls [0] Controls OPTIONAL
        }

41  43 -> 0   0x0   length = 0
    ]
]
     
     ------------------------------------------------------------------------ */
    public void testModifyMessage() throws Exception
    {
        byte[] pdu = {0x30, 0x28, 0x02, 0x01, 0x11, 0x66, 0x23, 0x04, 0x1F, 0x75, 0x69, 0x64, 0x3D, 0x61, 0x6B, 0x61, 0x72, 0x61, 0x73, 0x75, 0x6C, 0x75, 0x2C, 0x64, 0x63, 0x3D, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2C, 0x64, 0x63, 0x3D, 0x63, 0x6F, 0x6D, 0x30, 0x00};

        decode( pdu ) ;
        roundTripTest( pdu ) ;
        assertFalse( tlvList.isEmpty() ) ;
    }


    public void testSearchMessage() throws Exception
    {
        byte[] pdu = {0x30, 0x27, 0x02, 0x01, 0x01, 0x63, 0x22, 0x04, 0x06, 0x64, 0x63, 0x3D, 0x63, 0x6F, 0x6D, 0x0A, 0x01, 0x00, 0x0A, 0x01, 0x03, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x01, 0x01, 0x00, 0xFFFFFF87, 0x07, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x30, 0x30, 0x00};

        decode( pdu ) ;
        roundTripTest( pdu ) ;
        assertFalse( tlvList.isEmpty() ) ;
    }
}
